name: Build and Release

on:
  push:
    tags:
      - "develop-v*"
      - "release-v*"

permissions:
  contents: write

jobs:
  build:
    name: Build - ${{ matrix.platform }}-${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows - x64
          - os: windows-latest
            platform: windows
            arch: x64
            target: x86_64-pc-windows-msvc
          # Linux - x64
          - os: ubuntu-22.04
            platform: linux
            arch: x64
            target: x86_64-unknown-linux-gnu
          # macOS - Intel (x64) - using macos-15-intel (supported until Aug 2027)
          - os: macos-15-intel
            platform: macos
            arch: x64
            target: x86_64-apple-darwin
          # macOS - Apple Silicon (arm64)
          - os: macos-latest
            platform: macos
            arch: arm64
            target: aarch64-apple-darwin

    outputs:
      version: ${{ steps.get_version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract Version from Tag
        id: get_version
        shell: bash
        run: |
          if [[ $GITHUB_REF == refs/tags/release-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/release-v}
          elif [[ $GITHUB_REF == refs/tags/develop-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/develop-v}
          else
            VERSION="0.0.0"
          fi
          echo "Detected version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update Configuration Files
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
        run: |
          # Update package.json
          if command -v jq &> /dev/null; then
            jq --arg v "$VERSION" '.version = $v' package.json > package.json.tmp && mv package.json.tmp package.json
            jq --arg v "$VERSION" '.version = $v' src-tauri/tauri.conf.json > src-tauri/tauri.conf.json.tmp && mv src-tauri/tauri.conf.json.tmp src-tauri/tauri.conf.json
          else
            # Fallback for systems without jq - use node
            node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync('package.json')); p.version='$VERSION'; fs.writeFileSync('package.json', JSON.stringify(p, null, 2));"
            node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); p.version='$VERSION'; fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(p, null, 2));"
          fi

          echo "Updated versions to: $VERSION"
          cat package.json | grep version || true
          cat src-tauri/tauri.conf.json | grep version || true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Rust Cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          cache-on-failure: true

      - name: Install Dependencies (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev librsvg2-dev patchelf libsoup-3.0-dev libjavascriptcoregtk-4.1-dev

      - name: Install Frontend Dependencies
        run: npm ci

      - name: Prepare Signing Key
        shell: bash
        run: |
          if [ -z "$RAW_KEY" ]; then
            echo "::error:: TAURI_SIGNING_PRIVATE_KEY is empty. Please check the 'Repository secrets'."
            exit 1
          fi

          # Debug: Print key length and first 20 characters
          echo "Key length: ${#RAW_KEY} characters"
          echo "Key starts with: ${RAW_KEY:0:20}..."

          # Check if key contains newlines
          if [[ "$RAW_KEY" == *$'\n'* ]]; then
            echo "Key contains newlines, using as-is."
            FINAL_KEY="$RAW_KEY"
          elif [[ "$RAW_KEY" == "untrusted comment:"* ]]; then
            # Key has header but no newline - need to split
            echo "Key has header but no newline, attempting to split..."
            # Tách phần header và phần base64
            HEADER=$(echo "$RAW_KEY" | grep -oP '^untrusted comment:[^A-Z0-9+/=]+' | sed 's/ *$//')
            BASE64_PART=$(echo "$RAW_KEY" | sed 's/^untrusted comment:[^A-Z0-9+/=]*//')
            if [ -n "$BASE64_PART" ]; then
              FINAL_KEY="${HEADER}"$'\n'"${BASE64_PART}"
              echo "Split successful. Header: ${HEADER}"
            else
              echo "::error:: TAURI_SIGNING_PRIVATE_KEY is not valid. Please check the 'Repository secrets'."
              exit 1
            fi
          else
            # Key is base64 only, need to add header
            echo "Key is base64 only, adding header..."
            FINAL_KEY="untrusted comment: tauri signing key"$'\n'"$RAW_KEY"
          fi

          # Write key to GITHUB_ENV using heredoc
          {
            echo "TAURI_SIGNING_PRIVATE_KEY<<SIGNING_KEY_EOF"
            printf '%s\n' "$FINAL_KEY"
            echo "SIGNING_KEY_EOF"
          } >> $GITHUB_ENV

          echo "Key prepared successfully."
        env:
          RAW_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}

      - name: Build Tauri App
        run: npm run tauri build -- --target ${{ matrix.target }}
        env:
          # TAURI_SIGNING_PRIVATE_KEY is now provided via GITHUB_ENV from the previous step
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Rename and Prepare Artifacts
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          PLATFORM: ${{ matrix.platform }}
          ARCH: ${{ matrix.arch }}
          TARGET: ${{ matrix.target }}
        run: |
          mkdir -p release-artifacts
          echo "=== Debug: Listing bundle directory ==="
          ls -R src-tauri/target/$TARGET/release/bundle || true

          # Windows
          if [ "$PLATFORM" == "windows" ]; then
            cp src-tauri/target/$TARGET/release/bundle/nsis/*.exe "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}-setup.exe" 2>/dev/null || true
            cp src-tauri/target/$TARGET/release/bundle/msi/*.msi "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}.msi" 2>/dev/null || true
            
            # Find and rename Windows Updater Bundle
            BUNDLE=$(find src-tauri/target/$TARGET/release/bundle -name "*.msi.zip" | head -n 1)
            if [ -n "$BUNDLE" ]; then
              cp "$BUNDLE" "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}-updater.msi.zip"
            fi
            
          # Linux
          elif [ "$PLATFORM" == "linux" ]; then
            cp src-tauri/target/$TARGET/release/bundle/appimage/*.AppImage "release-artifacts/adbcompass-${VERSION}-linux-${ARCH}.AppImage" 2>/dev/null || true
            cp src-tauri/target/$TARGET/release/bundle/deb/*.deb "release-artifacts/adbcompass-${VERSION}-linux-${ARCH}.deb" 2>/dev/null || true
            
            # Find and rename Linux Updater Bundle
            BUNDLE=$(find src-tauri/target/$TARGET/release/bundle -name "*.AppImage.tar.gz" | head -n 1)
            if [ -n "$BUNDLE" ]; then
              cp "$BUNDLE" "release-artifacts/adbcompass-${VERSION}-linux-${ARCH}-updater.AppImage.tar.gz"
            fi

          # macOS
          elif [ "$PLATFORM" == "macos" ]; then
            cp src-tauri/target/$TARGET/release/bundle/dmg/*.dmg "release-artifacts/adbcompass-${VERSION}-macos-${ARCH}.dmg" 2>/dev/null || true
            
            # Find and rename macOS Updater Bundle
            BUNDLE=$(find src-tauri/target/$TARGET/release/bundle -name "*.app.tar.gz" | head -n 1)
            if [ -n "$BUNDLE" ]; then
              cp "$BUNDLE" "release-artifacts/adbcompass-${VERSION}-macos-${ARCH}-updater.app.tar.gz"
            fi
          fi

          # Recursive Signature Extraction (Tauri v2)
          echo "Extracting signatures..."
          find src-tauri/target/$TARGET/release/bundle -name "*.sig" | while read -r sig; do
            echo "Found signature: $sig"
            binary_name=$(basename "$sig" .sig)
            # Create a signature meta file mapping binary name to signature content
            sed -n '2p' "$sig" > "release-artifacts/${binary_name}.sig.txt"
          done

          # Fallback for old signature mapping if new one fails
          SIG_FILE=$(find src-tauri/target/$TARGET/release/bundle -name "*.sig" | head -n 1)
          if [ -n "$SIG_FILE" ]; then
            sed -n '2p' "$SIG_FILE" > "release-artifacts/${PLATFORM}-${ARCH}.legacy.sig.txt"
          fi

          echo "Artifacts prepared:"
          ls -la release-artifacts/

      - name: Create Windows Portable ZIP
        if: matrix.platform == 'windows'
        shell: pwsh
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          ARCH: ${{ matrix.arch }}
          TARGET: ${{ matrix.target }}
        run: |
          $portableExe = "release-artifacts/adbcompass-${env:VERSION}-windows-${env:ARCH}-portable.exe"
          $zipFile = "release-artifacts/adbcompass-${env:VERSION}-windows-${env:ARCH}-portable.zip"

          # Debug: List what we have
          Write-Host "=== Contents of release-artifacts ==="
          Get-ChildItem release-artifacts -ErrorAction SilentlyContinue | Format-Table Name, Length

          # If portable exe doesn't exist, try to find and copy it
          if (-not (Test-Path $portableExe)) {
            Write-Host "Portable exe not found at expected path, searching..."
            $releaseDir = "src-tauri/target/${env:TARGET}/release"
            
            # List all exes to debug
            Write-Host "=== EXEs in release folder ==="
            Get-ChildItem "$releaseDir/*.exe" -ErrorAction SilentlyContinue | Format-Table Name, Length
            
            # Try finding the main app exe
            $candidates = @(
              "$releaseDir/ADB Compass.exe",
              "$releaseDir/adb-compass.exe", 
              "$releaseDir/adbcompass.exe"
            )
            foreach ($candidate in $candidates) {
              if (Test-Path $candidate) {
                Copy-Item $candidate -Destination $portableExe
                Write-Host "Found and copied: $candidate"
                break
              }
            }
          }

          if (Test-Path $portableExe) {
            # Create temp folder and copy files
            New-Item -ItemType Directory -Force -Path "portable-temp" | Out-Null
            Copy-Item $portableExe -Destination "portable-temp/adbcompass.exe"
            
            # Bundle ALL DLLs from release folder (WebView2Loader.dll, etc.)
            $releaseDir = "src-tauri/target/${env:TARGET}/release"
            $dlls = Get-ChildItem "$releaseDir/*.dll" -ErrorAction SilentlyContinue
            foreach ($dll in $dlls) {
              Copy-Item $dll.FullName -Destination "portable-temp/"
              Write-Host "Bundled DLL: $($dll.Name)"
            }
            
            # Bundle ADB for portable version
            $adbExe = "src-tauri/binaries/adb.exe"
            if (Test-Path $adbExe) {
              Copy-Item $adbExe -Destination "portable-temp/"
              Write-Host "Bundled adb.exe"
            } else {
              Write-Host "WARNING: adb.exe not found at $adbExe"
            }
            
            # Also bundle ADB dependencies if they exist
            $adbDeps = @("AdbWinApi.dll", "AdbWinUsbApi.dll")
            foreach ($dep in $adbDeps) {
              $depPath = "src-tauri/binaries/$dep"
              if (Test-Path $depPath) {
                Copy-Item $depPath -Destination "portable-temp/"
                Write-Host "Bundled ADB dependency: $dep"
              }
            }
            
            # Create ZIP
            Compress-Archive -Path "portable-temp/*" -DestinationPath $zipFile -Force
            Remove-Item -Recurse -Force "portable-temp"
            
            Write-Host "Created portable ZIP: $zipFile"
            Write-Host "=== ZIP Contents ==="
            # Show contents
            Expand-Archive -Path $zipFile -DestinationPath "zip-check" -Force
            Get-ChildItem "zip-check" | Format-Table Name, Length
            Remove-Item -Recurse -Force "zip-check"
          } else {
            Write-Host "ERROR: Portable exe not found, skipping ZIP creation"
            Write-Host "This may indicate a build issue - check previous steps"
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.platform }}-${{ matrix.arch }}
          path: release-artifacts/*
          retention-days: 7
          if-no-files-found: warn

  create-release:
    name: Create Release & Update Manifest
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract Version from Tag
        id: get_version
        run: |
          if [[ $GITHUB_REF == refs/tags/release-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/release-v}
          elif [[ $GITHUB_REF == refs/tags/develop-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/develop-v}
          else
            VERSION="0.0.0"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: artifacts-*
          merge-multiple: true

      - name: Update updater.json
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const updater = JSON.parse(fs.readFileSync('updater.json', 'utf8'));
          const version = process.env.VERSION;
          const tagName = process.env.TAG_NAME;

          updater.version = version;
          updater.pub_date = new Date().toISOString();

          const platformMap = {
            'windows-x64': 'windows-x86_64',
            'linux-x64': 'linux-x86_64',
            'macos-x64': 'darwin-x86_64',
            'macos-arm64': 'darwin-aarch64'
          };

          const files = fs.readdirSync('artifacts');
          console.log('Available artifacts:', files);

          Object.entries(platformMap).forEach(([key, updaterKey]) => {
            console.log(`Processing platform: ${key} (${updaterKey})`);
            
            if (!updater.platforms[updaterKey]) return;

            const baseUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/releases/download/${tagName}`;
            
            // 1. Find the updater binary
            let binaryFile = files.find(f => f.includes(`${key}-updater`));
            
            // Fallback to legacy naming if standardized not found
            if (!binaryFile) {
                if (updaterKey === 'windows-x86_64') binaryFile = files.find(f => f.endsWith('.msi.zip'));
                else if (updaterKey === 'linux-x86_64') binaryFile = files.find(f => f.endsWith('.AppImage.tar.gz'));
                else if (updaterKey.startsWith('darwin')) binaryFile = files.find(f => f.includes(key) && f.endsWith('.app.tar.gz'));
            }

            if (binaryFile) {
                updater.platforms[updaterKey].url = `${baseUrl}/${binaryFile}`;
                console.log(`  Binary matched: ${binaryFile}`);

                // 2. Find the signature for this specific binary
                // The binary might be 'adbcompass-1.0.2-windows-x64-updater.msi.zip'
                // The sig meta file would be 'adbcompass-1.0.2-windows-x64-updater.msi.zip.sig.txt'
                // OR it might be 'adb-compass_0.1.0_x64-setup.exe.sig.txt'
                
                let sigContent = '';
                const sigFileName = `${binaryFile}.sig.txt`;
                const sigFile = `artifacts/${sigFileName}`;
                
                if (fs.existsSync(sigFile)) {
                    sigContent = fs.readFileSync(sigFile, 'utf8').trim();
                    console.log(`  Signature found via explicit mapping: ${sigFileName}`);
                } else {
                    // Fallback to legacy signature search
                    const legacySigFile = `artifacts/${key}.legacy.sig.txt`;
                    if (fs.existsSync(legacySigFile)) {
                        sigContent = fs.readFileSync(legacySigFile, 'utf8').trim();
                        console.log(`  Signature found via legacy fallback: ${legacySigFile}`);
                    }
                }

                if (sigContent) {
                    updater.platforms[updaterKey].signature = sigContent;
                } else {
                    console.log(`  WARNING: No signature found for ${binaryFile}`);
                }
            } else {
                console.log(`  WARNING: No updater binary found for ${updaterKey}`);
            }
          });

          fs.writeFileSync('updater.json', JSON.stringify(updater, null, 2));
          console.log('Update of updater.json completed.');
          EOF

      - name: Commit and Push updater.json
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add updater.json
          
          # Only commit if there are actual changes
          if git diff --staged --quiet; then
            echo "No changes in updater.json to commit."
            exit 0
          fi
          
          git commit -m "chore: update updater.json for version ${{ steps.get_version.outputs.version }} [skip ci]"
          
          # Fetch and rebase to avoid conflicts
          git fetch origin main
          git rebase origin/main
          
          # Push specifically from HEAD to remote main branch
          git push origin HEAD:main

      - name: Prepare Release Files
        run: |
          mkdir -p release-files
          # Copy only installers and portable versions, exclude .sig.txt files
          find artifacts -type f ! -name "*.sig.txt" -exec cp {} release-files/ \;
          echo "Files to be uploaded to release:"
          ls -la release-files/

      - name: Determine Release Type
        id: release_type
        run: |
          if [[ "${{ github.ref }}" == refs/tags/release-v* ]]; then
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "release_name=ADB Compass ${{ steps.get_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "release_name=Development Build ${{ steps.get_version.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.release_type.outputs.release_name }}
          tag_name: ${{ github.ref_name }}
          draft: false
          prerelease: ${{ steps.release_type.outputs.is_prerelease }}
          files: release-files/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
