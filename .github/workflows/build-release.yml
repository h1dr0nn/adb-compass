name: Build and Release

on:
  push:
    tags:
      - "develop-v*"
      - "release-v*"

permissions:
  contents: write

jobs:
  build:
    name: Build - ${{ matrix.platform }}-${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Windows - x64
          - os: windows-latest
            platform: windows
            arch: x64
            target: x86_64-pc-windows-msvc
          # Linux - x64
          - os: ubuntu-22.04
            platform: linux
            arch: x64
            target: x86_64-unknown-linux-gnu
          # macOS - Intel (x64) - using macos-15-intel (supported until Aug 2027)
          - os: macos-15-intel
            platform: macos
            arch: x64
            target: x86_64-apple-darwin
          # macOS - Apple Silicon (arm64)
          - os: macos-latest
            platform: macos
            arch: arm64
            target: aarch64-apple-darwin

    outputs:
      version: ${{ steps.get_version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract Version from Tag
        id: get_version
        shell: bash
        run: |
          if [[ $GITHUB_REF == refs/tags/release-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/release-v}
          elif [[ $GITHUB_REF == refs/tags/develop-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/develop-v}
          else
            VERSION="0.0.0"
          fi
          echo "Detected version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Update Configuration Files
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
        run: |
          # Update package.json
          if command -v jq &> /dev/null; then
            jq --arg v "$VERSION" '.version = $v' package.json > package.json.tmp && mv package.json.tmp package.json
            jq --arg v "$VERSION" '.version = $v' src-tauri/tauri.conf.json > src-tauri/tauri.conf.json.tmp && mv src-tauri/tauri.conf.json.tmp src-tauri/tauri.conf.json
          else
            # Fallback for systems without jq - use node
            node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync('package.json')); p.version='$VERSION'; fs.writeFileSync('package.json', JSON.stringify(p, null, 2));"
            node -e "const fs=require('fs'); const p=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json')); p.version='$VERSION'; fs.writeFileSync('src-tauri/tauri.conf.json', JSON.stringify(p, null, 2));"
          fi

          echo "Updated versions to: $VERSION"
          cat package.json | grep version || true
          cat src-tauri/tauri.conf.json | grep version || true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "npm"

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Setup Rust Cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          cache-on-failure: true

      - name: Install Dependencies (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libgtk-3-dev librsvg2-dev patchelf libsoup-3.0-dev libjavascriptcoregtk-4.1-dev

      - name: Install Frontend Dependencies
        run: npm ci

      - name: Build Tauri App
        run: npm run tauri build -- --target ${{ matrix.target }}
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}

      - name: Rename and Prepare Artifacts
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          PLATFORM: ${{ matrix.platform }}
          ARCH: ${{ matrix.arch }}
          TARGET: ${{ matrix.target }}
        run: |
          mkdir -p release-artifacts
          echo "=== Debug: Listing bundle directory ==="
          ls -R src-tauri/target/$TARGET/release/bundle || true

          # Windows
          if [ "$PLATFORM" == "windows" ]; then
            cp src-tauri/target/$TARGET/release/bundle/nsis/*.exe "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}-setup.exe" 2>/dev/null || true
            cp src-tauri/target/$TARGET/release/bundle/msi/*.msi "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}.msi" 2>/dev/null || true
            # Tauri Updater bundles for Windows (.msi.zip)
            find src-tauri/target/$TARGET/release/bundle -name "*.msi.zip" -exec cp {} release-artifacts/ \; 2>/dev/null || true
            
            # Portable logic (already exists in next step, but let's ensure we find the exe)
            PORTABLE_EXE=""
            for exe in "src-tauri/target/$TARGET/release/ADB Compass.exe" \
                       "src-tauri/target/$TARGET/release/adb-compass.exe"; do
              if [ -f "$exe" ]; then
                cp "$exe" "release-artifacts/adbcompass-${VERSION}-windows-${ARCH}-portable.exe"
                break
              fi
            done
          # Linux
          elif [ "$PLATFORM" == "linux" ]; then
            cp src-tauri/target/$TARGET/release/bundle/appimage/*.AppImage "release-artifacts/adbcompass-${VERSION}-linux-${ARCH}.AppImage" 2>/dev/null || true
            cp src-tauri/target/$TARGET/release/bundle/deb/*.deb "release-artifacts/adbcompass-${VERSION}-linux-${ARCH}.deb" 2>/dev/null || true
            # Tauri Updater bundles for Linux (.AppImage.tar.gz)
            find src-tauri/target/$TARGET/release/bundle -name "*.AppImage.tar.gz" -exec cp {} release-artifacts/ \; 2>/dev/null || true
          # macOS
          elif [ "$PLATFORM" == "macos" ]; then
            cp src-tauri/target/$TARGET/release/bundle/dmg/*.dmg "release-artifacts/adbcompass-${VERSION}-macos-${ARCH}.dmg" 2>/dev/null || true
            # Tauri Updater bundles for macOS (.app.tar.gz)
            find src-tauri/target/$TARGET/release/bundle -name "*.app.tar.gz" -exec cp {} release-artifacts/ \; 2>/dev/null || true
          fi

          # Extract and save signature for updater automation
          echo "Extracting signature..."
          SIG_FILE=$(find src-tauri/target/$TARGET/release/bundle -name "*.sig" | head -n 1)
          if [ -n "$SIG_FILE" ]; then
            echo "Found signature file: $SIG_FILE"
            sed -n '2p' "$SIG_FILE" > "release-artifacts/${PLATFORM}-${ARCH}.sig.txt"
          else
            echo "WARNING: No signature file found!"
          fi

          echo "Artifacts prepared:"
          ls -la release-artifacts/

      - name: Create Windows Portable ZIP
        if: matrix.platform == 'windows'
        shell: pwsh
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          ARCH: ${{ matrix.arch }}
          TARGET: ${{ matrix.target }}
        run: |
          $portableExe = "release-artifacts/adbcompass-${env:VERSION}-windows-${env:ARCH}-portable.exe"
          $zipFile = "release-artifacts/adbcompass-${env:VERSION}-windows-${env:ARCH}-portable.zip"

          # Debug: List what we have
          Write-Host "=== Contents of release-artifacts ==="
          Get-ChildItem release-artifacts -ErrorAction SilentlyContinue | Format-Table Name, Length

          # If portable exe doesn't exist, try to find and copy it
          if (-not (Test-Path $portableExe)) {
            Write-Host "Portable exe not found at expected path, searching..."
            $releaseDir = "src-tauri/target/${env:TARGET}/release"
            
            # List all exes to debug
            Write-Host "=== EXEs in release folder ==="
            Get-ChildItem "$releaseDir/*.exe" -ErrorAction SilentlyContinue | Format-Table Name, Length
            
            # Try finding the main app exe
            $candidates = @(
              "$releaseDir/ADB Compass.exe",
              "$releaseDir/adb-compass.exe", 
              "$releaseDir/adbcompass.exe"
            )
            foreach ($candidate in $candidates) {
              if (Test-Path $candidate) {
                Copy-Item $candidate -Destination $portableExe
                Write-Host "Found and copied: $candidate"
                break
              }
            }
          }

          if (Test-Path $portableExe) {
            # Create temp folder and copy files
            New-Item -ItemType Directory -Force -Path "portable-temp" | Out-Null
            Copy-Item $portableExe -Destination "portable-temp/adbcompass.exe"
            
            # Bundle ALL DLLs from release folder (WebView2Loader.dll, etc.)
            $releaseDir = "src-tauri/target/${env:TARGET}/release"
            $dlls = Get-ChildItem "$releaseDir/*.dll" -ErrorAction SilentlyContinue
            foreach ($dll in $dlls) {
              Copy-Item $dll.FullName -Destination "portable-temp/"
              Write-Host "Bundled DLL: $($dll.Name)"
            }
            
            # Bundle ADB for portable version
            $adbExe = "src-tauri/binaries/adb.exe"
            if (Test-Path $adbExe) {
              Copy-Item $adbExe -Destination "portable-temp/"
              Write-Host "Bundled adb.exe"
            } else {
              Write-Host "WARNING: adb.exe not found at $adbExe"
            }
            
            # Also bundle ADB dependencies if they exist
            $adbDeps = @("AdbWinApi.dll", "AdbWinUsbApi.dll")
            foreach ($dep in $adbDeps) {
              $depPath = "src-tauri/binaries/$dep"
              if (Test-Path $depPath) {
                Copy-Item $depPath -Destination "portable-temp/"
                Write-Host "Bundled ADB dependency: $dep"
              }
            }
            
            # Create ZIP
            Compress-Archive -Path "portable-temp/*" -DestinationPath $zipFile -Force
            Remove-Item -Recurse -Force "portable-temp"
            
            Write-Host "Created portable ZIP: $zipFile"
            Write-Host "=== ZIP Contents ==="
            # Show contents
            Expand-Archive -Path $zipFile -DestinationPath "zip-check" -Force
            Get-ChildItem "zip-check" | Format-Table Name, Length
            Remove-Item -Recurse -Force "zip-check"
          } else {
            Write-Host "ERROR: Portable exe not found, skipping ZIP creation"
            Write-Host "This may indicate a build issue - check previous steps"
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.platform }}-${{ matrix.arch }}
          path: release-artifacts/*
          retention-days: 7
          if-no-files-found: warn

  create-release:
    name: Create Release & Update Manifest
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract Version from Tag
        id: get_version
        run: |
          if [[ $GITHUB_REF == refs/tags/release-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/release-v}
          elif [[ $GITHUB_REF == refs/tags/develop-v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/develop-v}
          else
            VERSION="0.0.0"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: artifacts-*
          merge-multiple: true

      - name: Update updater.json
        shell: bash
        env:
          VERSION: ${{ steps.get_version.outputs.version }}
          TAG_NAME: ${{ github.ref_name }}
        run: |
          node << 'EOF'
          const fs = require('fs');
          const path = require('path');
          const updater = JSON.parse(fs.readFileSync('updater.json', 'utf8'));
          const version = process.env.VERSION;
          const tagName = process.env.TAG_NAME;

          updater.version = version;
          updater.pub_date = new Date().toISOString();

          const platformMap = {
            'windows-x64': 'windows-x86_64',
            'linux-x64': 'linux-x86_64',
            'macos-x64': 'darwin-x86_64',
            'macos-arm64': 'darwin-aarch64'
          };

          const files = fs.readdirSync('artifacts');
          console.log('Available artifacts:', files);

          Object.entries(platformMap).forEach(([key, updaterKey]) => {
            const sigFile = `artifacts/${key}.sig.txt`;
            if (fs.existsSync(sigFile)) {
              const signature = fs.readFileSync(sigFile, 'utf8').trim();
              if (updater.platforms[updaterKey]) {
                updater.platforms[updaterKey].signature = signature;
                const baseUrl = `https://github.com/${process.env.GITHUB_REPOSITORY}/releases/download/${tagName}`;
                
                // Find the best binary for the updater (prioritize .zip/.tar.gz update bundles)
                let binaryFile = '';
                if (updaterKey === 'windows-x86_64') {
                    binaryFile = files.find(f => f.endsWith('.msi.zip')) || files.find(f => f.endsWith('.exe'));
                } else if (updaterKey === 'linux-x86_64') {
                    binaryFile = files.find(f => f.endsWith('.AppImage.tar.gz')) || files.find(f => f.endsWith('.AppImage'));
                } else if (updaterKey === 'darwin-x86_64') {
                    binaryFile = files.find(f => f.endsWith('x64.app.tar.gz')) || files.find(f => f.endsWith('x64.dmg'));
                } else if (updaterKey === 'darwin-aarch64') {
                    binaryFile = files.find(f => f.endsWith('arm64.app.tar.gz')) || files.find(f => f.endsWith('arm64.dmg'));
                }

                if (binaryFile) {
                    updater.platforms[updaterKey].url = `${baseUrl}/${binaryFile}`;
                    console.log(`Updated ${updaterKey} with signature and URL: ${binaryFile}`);
                } else {
                    console.log(`Warning: No binary found for ${updaterKey}`);
                }
              }
            } else {
              console.log(`Warning: Signature file not found for ${key}`);
            }
          });

          fs.writeFileSync('updater.json', JSON.stringify(updater, null, 2));
          console.log('Updated updater.json successfully');
          EOF

      - name: Commit and Push updater.json
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add updater.json
          
          # Only commit if there are actual changes
          if git diff --staged --quiet; then
            echo "No changes in updater.json to commit."
            exit 0
          fi
          
          git commit -m "chore: update updater.json for version ${{ steps.get_version.outputs.version }} [skip ci]"
          
          # Fetch and rebase to avoid conflicts
          git fetch origin main
          git rebase origin/main
          
          # Push specifically from HEAD to remote main branch
          git push origin HEAD:main

      - name: Prepare Release Files
        run: |
          mkdir -p release-files
          # Copy only installers and portable versions, exclude .sig.txt files
          find artifacts -type f ! -name "*.sig.txt" -exec cp {} release-files/ \;
          echo "Files to be uploaded to release:"
          ls -la release-files/

      - name: Determine Release Type
        id: release_type
        run: |
          if [[ "${{ github.ref }}" == refs/tags/release-v* ]]; then
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "release_name=ADB Compass ${{ steps.get_version.outputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "release_name=Development Build ${{ steps.get_version.outputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ steps.release_type.outputs.release_name }}
          tag_name: ${{ github.ref_name }}
          draft: false
          prerelease: ${{ steps.release_type.outputs.is_prerelease }}
          files: release-files/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
